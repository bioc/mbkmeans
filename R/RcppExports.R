# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
debug <- function(clusters, cent, data) {
    .Call(`_mbkmeans_debug`, clusters, cent, data)
}

#' Predict_mini_batch
#'
#' Prediction function for Mini-batch-k-means for in-memory, delayed, and on-disk matrices
#'
#'
#'@param data matrix, DelayedMatrix, or HDF5Matrix containing numeric or
#'  integer data (obseravtions in rows, variables in columns)
#'@param CENTROIDS a matrix of initial cluster centroids. The rows of the
#'  CENTROIDS matrix should be equal to the number of clusters and the columns
#'  should equal the columns of the data.
#'@return it returns a vector with the clusters.
#'@details
#'
#'This function takes the data and the output centroids and returns the
#'clusters.
#'
#'This implementation relies very heavily on the
#'\code{\link[ClusterR]{MiniBatchKmeans}} implementation. We provide the
#'ability to work with DelayedMatrix and HDF5Matrix through the \code{beachmat}
#'library.
#'
#'@author Lampros Mouselimis and Yuwei Ni
#'
#'@examples
#'data(iris)
#'km = mini_batch(as.matrix(iris[,1:4]), clusters = 3,
#'                batch_size = 10, max_iters = 10)
#'clusters = predict_mini_batch(as.matrix(iris[,1:4]),
#'                              CENTROIDS = km$centroids)
#' @export
predict_mini_batch <- function(data, CENTROIDS, fuzzy = FALSE, eps = 1.0e-6) {
    .Call(`_mbkmeans_predict_mini_batch`, data, CENTROIDS, fuzzy, eps)
}

compute_wcss <- function(clusters, cent, data) {
    .Call(`_mbkmeans_compute_wcss`, clusters, cent, data)
}

#'
#' Mini_batch
#'
#' Mini-batch-k-means for both matrix and HDF5Matrix
#'
#'@param data numeric matrix or integer matrix or HDF5Matrix
#'@param clusters the number of clusters
#'@param batch_size the size of the mini batches
#'@param num_init number of times the algorithm will be run with different centroid seeds
#'@param max_iters the maximum number of clustering iterations
#'@param init_fraction percentage of data to use for the initialization centroids (applies if initializer is \emph{kmeans++} ). Should be a float number between 0.0 and 1.0.
#'@param initializer the method of initialization. One of \emph{kmeans++} and \emph{random}. See details for more information
#'@param early_stop_iter continue that many iterations after calculation of the best within-cluster-sum-of-squared-error
#'@param verbose either TRUE or FALSE, indicating whether progress is printed during clustering
#'@param CENTROIDS a matrix of initial cluster centroids. The rows of the CENTROIDS matrix should be equal to the number of clusters and the columns should be equal to the columns of the data
#'@param tol a float number. If, in case of an iteration (iteration > 1 and iteration < max_iters) 'tol' is greater than the squared norm of the centroids, then kmeans has converged
#'@param seed integer value for random number generator (RNG)
#'@return a list with the following attributes: centroids, WCSS_per_cluster, best_initialization, iters_per_initialization
#'@details
#'This function performs k-means clustering using mini batches.
#'
#'\strong{kmeans++}: kmeans++ initialization. Reference : http://theory.stanford.edu/~sergei/papers/kMeansPP-soda.pdf AND http://stackoverflow.com/questions/5466323/how-exactly-does-k-means-work
#'
#'\strong{random}: random selection of data rows as initial centroids
#'
#'@references
#'https://github.com/mlampros/ClusterR
#'
#'@examples
#'data = matrix(1:30,nrow = 10)
#'mini_batch(data, 2, 10, 10)
#'
#' @export
mini_batch <- function(data, clusters, batch_size, max_iters, num_init = 1L, init_fraction = 1.0, initializer = "kmeans++", early_stop_iter = 10L, verbose = FALSE, CENTROIDS = NULL, tol = 1e-4, seed = 1L) {
    .Call(`_mbkmeans_mini_batch`, data, clusters, batch_size, max_iters, num_init, init_fraction, initializer, early_stop_iter, verbose, CENTROIDS, tol, seed)
}

